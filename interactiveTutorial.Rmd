---
title: "R als GIS ‚Äî Eine kleine Einf√ºhrung"
author: "Marko Lipka"
date: '2019-04-05'
output: learnr::tutorial
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library(learnr)
knitr::opts_chunk$set(echo = TRUE, results = "hold", comment = NA)

flurstuecksflaechen_ha <- c(Horst     = 0.23, 
                            Ingeborg  = 42.000000,
                            Jaqueline = 11.111111,
                            Kurti     = 12.345678)
wd <- "/srv/shiny-server/RasGIStutorial_german"
```

# **R**-Grundlagen:

## Skripte

Skripte sind Programme die in *Skriptsprachen* geschrieben sind. Es sind Textdateien die mit einem normalen Texteditor bearbeitet werden k√∂nnen. Diese Skripte werden vom *Interpreter* der jeweiligen Sprache *ausgef√ºhrt*. Man k√∂nnte also im Windows-Editor **R**-Skripte schreiben, die man dann mit dem **R**-*Interpreter* (muss man zun√§chst [installieren](http://www.r-project.org)) *ausf√ºhrt*. Viel sch√∂ner ist es aber, in einer sogenannten Entwicklungsumgebung zu arbeiten, die Editor, Interpreter, Hilfeseiten und viele, viele kleine und gro√üe Helferlein in sich vereint. F√ºr **R** kann ich uneingeschr√§nkt die Entwicklungsumgebung [**RStudio**](http://www.rstudio.com) empfehlen, sie ist sehr gut.


Ein Programm oder Skript ist also eine Abfolge von Anweisungen, die der *Interpreter* so √ºbersetzt, dass der Computer sie *ausf√ºhren* kann. So wie Dein Hirn eine Dir bekannte Fremdsprache so √ºbersetzt, dass Du mit dem Gesagten etwas anfangen kannst. Was genau der Interpreter anstellt, ist nicht wichtig. Entscheidend ist, dass wir eine Sprache lernen wollen, mit der wir dem Computer beibringen k√∂nnen, Dinge f√ºr uns zu tun...

Jede Programmiersprache erm√∂glicht zudem das einf√ºgen von Kommentaren, die vom *Interpreter* ignoriert werden. In **R** werden Kommentare von einem `#`-Zeichen eingeleitet.
Kommentare sind wichtig, um den Programmcode zu erl√§utern, andere Menschen oder das zuk√ºnftige Selbst k√∂nnen es sonst schwer haben, das Programm zu verstehen.  
Kommentare sollen den Programmcode erl√§utern, nicht noch einmal beschreiben, was der Code tut. Gut geschriebener Code erkl√§rt sich bestenfalls selbst. Die Kommentare geben zus√§tzlich Aufschluss √ºber die Absichten und Gedanken des Autors sowie z.B. Fallstricke, in die er schon gestolpert ist. 
Wie wichtig Kommentare sind, realisiert man z.B. w√§hrend man seinen eigenen Code von letzter Woche nicht mehr versteht.

> `Die folgenden Beispiele zeigen Programmcode im grau hinterlegten Kasten.`  
> Die zugeh√∂rige Ausgabe (falls es eine gibt) findet sich jeweils im Kasten darunter.

Programmieren lernt man am besten durch Machen... also ran an die Tasten, die Beispiele nachvollziehen und spielen!  
In Konsolenfenstern wie diesen kannst du es einfach ausprobieren, 
stell' sie Dir wie eine Zelle in einem Excel-Sheet vor (nur ohne dass man ein "=" voranstellt und eben viel cooler ;-). Ausgef√ºhrt wird der Code per Klick auf den "Run Code"-Button oben rechts an der Konsole oder per Tastenkombination **Alt** + **Enter**:

```{r playground, exercise=TRUE, exercise.lines = 2}
# Benutze die Konsole als Taschenrechner und berechne 2*3*7!:

```

```{r playground-solution}
# Benutze die Konsole als Taschenrechner und berechne 2*3*7!:
2*3*7
```


Ein sehr einfaches **R**-Skript:

```{r}
"Hello world!" # Ausgabe einer Zeichenkette
1 + 1 # Addieren zweier Zahlen und Ausgabe des Ergebnisses
```

Das obige Skript besteht aus zwei Zeilen mit jeweils einem Befehl und erkl√§rendem Kommentar dahinter:

 * Die erste Zeile bewirkt das Ausgeben des Texts "Hello world!".
 * Die zweite Zeile z√§hlt eins und eins zusammen und gibt das Ergebnis zur√ºck.

Beide Befehle haben jeweils einen *R√ºckgabewert*, der im Konsolenfenster ausgegeben wird. Einmal den Text **"Hello world!"**
und
einmal die Zahl **2**.

Und was soll die **[1]** davor bedeuten?
Ausgaben in **R** werden nummeriert und die Nummer des ersten Elements jeder Zeile steht in eckigen Klammern voran, wobei mit jedem neuen Befehl die Z√§hlung wieder bei 1 beginnt. Folgendes Beipiel zur Verdeutlichung:

```{r}
1:42 # 1:42 ist eine Kurzform zur Erzeugung einer Reihe ganzer Zahlen von 1 bis 42
## Tip: dies k√∂nnte sp√§ter in einer √úbung n√ºtzlich sein =)
```

Mal sehen, ob schon was h√§ngen geblieben ist:

```{r Kommentare-zeichen, echo=FALSE}
question("Welches Zeichen leitet in R-Code Kommentare ein?",
         answer("#", correct = TRUE),
         answer("!!!", message = "Nein, damit beendet man S√§tze in Internet-Diskussionen."),
         answer(" =", message = "Ganz falsch, auch wenn's ein bisschen √Ñhnlichkeit hat."),
         answer("üí©", message = "Nein, das ist f√ºr was anderes gut..."))
```

```{r Kommentare-wichtig, echo=FALSE}
question("Wof√ºr sind Kommentare in Programmiersprachen gedacht?",
  answer("Zum deaktivieren von unn√ºtzen Codezeilen, die man aber noch nicht l√∂schen m√∂chte.", message = "Ja, man kann Code-Zeilen auch auskommentieren, also durch das Voranstellen des Kommentar-Zeichens deaktivieren. Das ist aber nicht der Zweck von Kommentaren!"),
  answer("Zur Erg√§nzungen von Gedanken, Notizen und hilfreichen Bemerkungen f√ºr das Verst√§ndnis des Codes.", correct = TRUE),
  answer("Nur f√ºr Anf√§nger, Profis brauchen das nicht.", message = "Ganz im Gegenteil: Anf√§nger verzichten oft leichtfertig auf Kommentare und lernen ihren Wert erst mit der Zeit zu sch√§tzen."),
  answer("Deine Mutter!", message = "√Ñh, ja... Versuch's nochmal.")
)
```

## Variablen

Variablen sind **Platzhalter** f√ºr Daten. Sie k√∂nne beliebige Arten und Mengen von Daten enthalten und sollten daher immer sinnvoll benannt sein. In **R** werden Daten mit dem Zuweisungsoperator `<-` in Variablen geschrieben:

```{r}
eine_zahl <- 23
```

Das Auslesen einer Variable geschieht durch simples 'ausf√ºhren' des Variablennamens:

```{r}
eine_zahl
```


Als Variablenname ist alles erlaubt, was mit einem Buchstaben beginnt. Es gibt gewisse Ausnahmen: so d√ºrfen Variablen z.B. auch mit einem '.' oder '_' beginnen. Ziffern, Rechen- und Vergleichsoperatoren ('+', '<', '=', ...) sind aber tabu!.
Man sollte au√üerdem keine Namen verwenden, die bereits vergeben sind (Funktionennamen, '*TRUE*' und '*FALSE*', ...), das kann sonst unerwartetes Verhalten des Programms hervorrufen.

Aussagekr√§ftige Variablennamen helfen sehr beim Verst√§ndnis des Programmcodes! Zusammen mit ordentlichen Kommentaren machen verst√§ndliche Variablennamen DEN Unterschied zwischen Code, der NUR vom Computer verstanden wird (wenn √ºberhaupt) und Quelltext, den auch ein Programmierer nachvollziehen kann. 


```{r}
summe <- eine_zahl + 19
summe
```

Im obigen Skript wird 

 1) die Summe aus *eine.zahl* + 19 gebildet und in die Variable *summe* geschrieben,
 2) das Ergebnis der Berechnung ausgegeben.
 
 Beachte: Das Ergebniss der ersten Zeile wird nicht ausgegeben sondern in die Variable *summe* geschrieben. Die zweite Zeile hingegen schreibt nicht in eine Variable sondern gibt ihr Ergebnis auf dem Bildschirm aus.

Eine Finger√ºbung:

```{r VariablenZahl, exercise = TRUE}
# Schreibe eine beliebige Zahl in die Variable 'zahl' ...
...
# ... und gib diese Zahl auf der Konsole aus:
zahl # Ausgabe der gew√§hlten Zahl auf der Konsole
```




## Funktionen

In **R** wird fast alles mit *Funktionen* erledigt. Als Excel-User ist man mit dem Konzept bereits vertraut. In **R** funktioniert das eigentlich genauso, nur das es viel mehr Funktionen gibt. Funktionen nehmen meistens wenigstens eine Eingabe entgegen, tun damit etwas (was normalerweise im Zusammenhang mit dem Funktionsnamen steht) und geben in der Regel ein Ergebnis zur√ºck.

Die Funktion `round()` zum Beispiel rundet einen numerischen Wert:

```{r}
round(1.234)
```

Probier ein wenig herum! Welche Funktion k√∂nnte die Summe einer Reihe von Zahlen ausgeben?

```{r Funktionen, exercise = TRUE}
...(1, 2, 3)
```

```{r Funktionen-solution}
sum(1, 2, 3)
```


Das wenden wir doch gleich mal an (wenn Du nicht weiter kommst, dr√ºck den Hint-Button f√ºr Hinweise):

```{r reihensumme, exercise=TRUE, exercise.lines = 6}
# Gib die Zahlen von 1 bis 100 auf der Konsole aus:

# Schreibe das Ergebnis in eine variable Namens 'eins_bis_hundert':

# Bilde die Summe all dieser Zahlen. Benutze daf√ºr die Funktion sum():

```

```{r reihensumme-hint-1}
# Gib die Zahlen von 1 bis 100 auf der Konsole aus:
von:bis
# Schreibe das Ergebnis in eine variable Namens 'eins_bis_hundert':

# Bilde die Summe all dieser Zahlen. Benutze daf√ºr die Funktion sum():

```

```{r reihensumme-hint-2}
# Gib die Zahlen von 1 bis 100 auf der Konsole aus:
1:100
# Schreibe das Ergebnis in eine variable Namens 'eins_bis_hundert':
eins_bis_hundert <- ...
# Bilde die Summe all dieser Zahlen. Benutze daf√ºr die Funktion sum():

```

```{r reihensumme-hint-3}
# Gib die Zahlen von 1 bis 100 auf der Konsole aus:
1:100
# Schreibe das Ergebnis in eine variable Namens 'eins_bis_hundert':
eins_bis_hundert <- 1:100
# Bilde die Summe all dieser Zahlen. Benutze daf√ºr die Funktion sum():
...(eins_bis_hundert)
```

```{r reihensumme-solution}
# Gib die Zahlen von 1 bis 100 auf der Konsole aus:
1:100
# Schreibe das Ergebnis in eine variable Namens 'eins_bis_hundert':
eins_bis_hundert <- 1:100
# Bilde die Summe all dieser Zahlen. Benutze daf√ºr die Funktion sum():
sum(eins_bis_hundert)
```

Du kennst nun die Funktionen `sum()` und `round()`.
L√∂se damit folgende Aufgabe:  
Die Variable `flurstuecksflaechen_ha` enth√§lt die Fl√§chenma√üe einer Reihe von Flurst√ºcken in einem Windeignungsgebiet. Ermittle die Gesamtfl√§che der Flurst√ºcke, runde das Ergebnis und schreibe es in die Variable `gesamtflaeche_ha`.

```{r RundeReihe, exercise = TRUE, exercise.lines = 6}
# Schau dir den Inhalt der variable 'flurstuecksflaechen_ha' erst einmal an:

# Berechne die Summe aller Werte in dieser Variable und gebe das Ergebnis auf der Konsole aus:

# Erweitere die Code-Zeile so, dass die Summe gerundet wird. Gib das Ergebnis auf der Konsole aus:

```

```{r RundeReihe-solution}
# Schau dir den Inhalt der variable 'flurstuecksflaechen_ha' erst einmal an:
flurstuecksflaechen_ha
# Berechne die Summe aller Werte in dieser Variable und gebe das Ergebnis auf der Konsole aus:
sum(flurstuecksflaechen_ha)
# Erweitere die Code-Zeile so, dass die Summe gerundet wird. Gib das Ergebnis auf der Konsole aus:
round(sum(flurstuecksflaechen_ha))
```

Die Teile innerhalb der Klammer einer Funktion hei√üen *Argumente*.
Funktionen haben oft mehrere Argumente, diese sind dann durch Kommata getrennt, k√∂nnen aber auch mit nur einem oder gar keinem Argument aufgerufen werden. Welche Argumente eine Funktion kennt, entnimmt man dem Handbuch, das es zu jeder Funktion gibt. Alternativ l√§sst man sich von der Auto-Vervollst√§ndigung seiner Entwicklungsumgebung (z.B. **RStudio**) helfen:

```{r AutoCompletion, exercise = TRUE}
# Tippe "round(" und anschlie√üend die Tab-Taste (‚Üπ)

# es sollte eine Auswahl der Argumente erscheinen, die die Funktion kennt.
```


Im folgenden Beispiel werden der Funktion `round()` *zwei* Argument mitgegeben, die zu rundende Zahl (*x*) und die Anzahl Dezimalstellen (*digits*) auf die gerundet werden soll. Die Argumente k√∂nnen, m√ºssen aber nicht, mit ihrem Namen aufgerufen werden. 
W√§hlt man die faule Variante (ohne Namen), muss man unbedingt auf die richtige **Reihenfolge der Argumente** achten.
Am Anfang empfiehlt es sich, sicherheitshalber alle Argumente zu benennen. 

```{r Argumente}
# Aufruf mit Argument-Namen in der 'richtigen' Reihenfolge:
round(x = 1.234, digits = 2) # empfohlen, gerade f√ºr Anf√§nger
# Aufruf ohne Argument-Namen in der 'richtigen' Reihenfolge:
round(1.234, 2) # faul und oft unverst√§ndlich
# Aufruf teils mit, teils ohne Argument-Namen:
round(1.234, digits = 2) # h√§ufig, der Kompromiss


# Aufruf mit Argument-Namen in anderer Reihenfolge:
round(digits = 2, x = 1.234) # un√ºblich und verwirrend
# Aufruf ohne Argument-Namen in FALSCHER Reihenfolge:
round(2, 1.234) # sowas kommt von sowas, n√§mlich !!
```

Mal sehen, ob du alles Wichtige mitgeschnitten hast:

```{r Funktionen-quiz, echo=FALSE}
question("Welche Aussagen treffen f√ºr Funktionen der Programmiersprache R zu?",
  answer("Eine Funktion kann mit mehreren Argumenten aufgerufen werden; dann muss man auf die richtige Reihenefolge oder die korrekte Benennung der Argumente achten.", correct = TRUE),
  answer("Funktionen spielen in R nur eine untergeordnete Rolle.", message = "Nein, Funktionen sind ein ganz zentraler Bestandteil der Sprache R."), 
  answer("Man muss jeder Funktion ein =-Zeichen voranstellen, damit sie korrekt ausgef√ºhrt wird.", message = "Das hast du wohl mit Excel verwechselt =)"), 
  answer("Die R√ºckgabe einer Funktion, ihr Ergebnis, kann in einer Variable f√ºr die sp√§tere Verwendung gespeichert werden.", correct = TRUE)
)
```

## Datentypen und -strukturen:

Es ist wichtig, darauf zu achten, was f√ºr eine Art Daten man verarbeitet. Es gibt neben numerischen Werten (*numeric*) und Zeichenketten (*character*) noch viele weitere, aber f√ºr den Anfang reichen uns die beiden wichtigsten.

```{r}
# Zeichenketten werden von Anf√ºhrungszeichen gerahmt
beispieltext <- "zweiundvierzig"
text_der_aussieht_wie_eine_zahl <- "42"

eine_echte_zahl <- 42 # das ist eine Zahl, man kann damit rechnen
eine_echte_zahl + 0
```

Daten k√∂nnen in ganz verschiedenen (und beinahe beliebig komplexen) Kombinationen und Strukturen angeordnet sein.

In der einfachsten Form, steckt nur ein einzelner Wert in einer Variable, so wie in den Beispielen *beispieltext* oder *eine_echte_zahl* oben.

```{r}
# try it out

# Teile den Wert, der in 'eine_echte_zahl' steht, durch 9 und schreibe das Ergebnis in die variable 'neuntel_echte_zahl'

# runde den Wert in 'neuntel_echte_zahl' auf eine ganze Zahl.

# versuche, den Wert aus 'text_der_aussieht_wie_eine_zahl' zu runden.
# Verstehe die Fehlermeldung! Man sollte Fehler und Warnungen beachten denn sie sind als Hilfestellung f√ºr die Fehlersuche gedacht und sind tats√§chlich meistens hilfreich! Als langj√§hriger Windows-Nutzer muss man sich allerdings erstmal daran gew√∂hnen, Fehlermeldungen wieder ernst zu nehmen.
```


### Vector

Oft werden aber auch Reihen von gleichartigen Werten in einer Variable ablegelt, sogenannte Vektoren (*vector*). Man kann sie auf verschiedene Arten generieren, meist durch das Verketten von Einzelelementen mithilfe der Funktion `c()` (*concatenate*).


```{r}
drei_vier_und_fuenf <- c(3, 4, 5) # 'c' steht f√ºr concatenate (verkn√ºpfen)
drei_vier_und_fuenf # gibt die eben abgelegte Zahlenreihe aus

ganzzahlen_von_eins_bis_zehn <- 1:10 # die faule Variante, eine Zahlenreihe zu generieren
ganzzahlen_von_eins_bis_zehn 

grossbuchstaben <- c("A", "B", "C", "D") # ein vector vom Typ 'character'
grossbuchstaben
```

Eine wichtige Eigenschaft des Vektors ist, dass alle seine Elemente denselben Datentyp haben. Versuchen wir mal, einen Vektor mit verschiedenen Datentypen zu erstellen:

```{r}
gemischter_vector <- c(3, 4, "f√ºnf")
gemischter_vector
```

**R** speichert dann alle Elemente in einem einheitlichen Datentyp.
Kannst du erkennen, welchen Datentyp *gemischter.vector* hat und warum?[^L√∂sung1]

[^L√∂sung1]: In die Variable *gemischter.vector* wurden zwei Zahlen (*numeric*) und ein Textstring (*character*) aneinandergekettet. In so einem Fall w√§hlt **R** den Datentyp f√ºr den vector aus, in dem jeder Wert ohne Informatiosverlust gespeichert werden kann, n√§mlich *character*. Der String "f√ºnf" l√§sst sich nicht als *numeric* speichern, die Zahlen aber sehr wohl als *character*.

Mit Vektoren vom Typ *numeric* kann man rechnen:

```{r}
# Berechnen wir die Mittelwerte der beiden Zahlenreihen:
mean(drei_vier_und_fuenf)
mean(ganzzahlen_von_eins_bis_zehn) 
```


Enth√§lt der Vektor Daten vom Typ *character*, sind numerische Operationen nicht m√∂glich:

```{r}
mean(grossbuchstaben)
```

Das Ergebnis des Versuchs, den Mittelwert aus einer Reihe von Buchstaben zu bilden, ist **NA**, was so viel wie '*not applicable*' (nicht anwendbar, nicht zutreffend) oder '*not available*' (nicht verf√ºgbar) bedeutet. Zus√§tzlich wird eine Warnung ausgegeben, dass nicht-numerische Daten in die Funktion *mean()* gef√ºttert wurden.

Was w√ºrde der Aufruf von `mean(gemischter_vector)` f√ºr eine Ausgabe bewirken?[^L√∂sungGemischterVektor]

[^L√∂sungGemischterVektor]: Der Aufruf von `mean(gemischter.vector)` ergibt dieselbe Ausgabe wie zuvor `mean(grossbuchstaben)`, n√§mlich eine Warnung und 'NA'. Da wir *gemischter_vector* mittels Verkettung von Zahlen und Text gef√ºttert haben, muss der Datentyp einheitlich *character* sein, also nicht-numerisch. 

### Data frame (Tabellen)

Eine sehr n√ºtzliche und weithin bekannte Struktur ist die  **Tabelle** (in **R** *data.frame* genannt):

```{r}
data.frame_beispiel <- data.frame(Zahlen = 23:42,
                                 Text = beispieltext,
                                 mehrText = "42")

data.frame_beispiel
```

Der Code produziert eine Tabelle mit 20 Zeilen, da die erste Spalte die Zahlen 23 bis 42 enthalten soll. Die beiden weiteren Spalten wurden jeweils mit nur einem einzelnen Wert gef√ºttert, der folglich einfach immer wiederholt wird.

Anders als in Excel zum Beispiel, haben die Spalten jeweils einen einheitlichen Datentyp (wie beim Vektor). Das hei√üt, die gesamte Spalte "*Text*" im Beispiel oben hat den Datentyp **character**, jede 'Zelle' der Spalte "*Zahlen*" hat den Typ **numeric**.

Tabellen haben **eindeutige** Spaltennamen, Spaltennummern und Zeilennummern, mit denen die Daten darin addressiert werden k√∂nnen. Daf√ºr gibt es verschiedene M√∂glichkeiten, hier ein paar Beispiele f√ºr das Auslesen von einzelnen Spalten, Zeilen und Zellen mittels Indices:

```{r}
# Der Wert vor dem Komma in eckigen Klammern adressiert die Zeilen der Tabelle ...
data.frame_beispiel[3, ] # nur die dritte Zeile der Tabelle
```

```{r}
#... der Wert hinter dem Komma adressiert die Spalten (wahlweise Name oder Nummer).
data.frame_beispiel[, "Zahlen"] # alle Werte aus Spalte "Zahlen"
```

```{r}
# Gibt man beide Werte an, Zeile und Spalte, erh√§lt man den Wert aus dieser Zelle:
data.frame_beispiel[1, 1] # Wert aus Zeile 1, Spalte 1
```



Extrem m√§chtige und dabei sehr einfach zu bedienende Werkzeuge zum Filtern und Manipulieren von Tabellen lernen wir in einem sp√§teren Kapitel[^UnderConstruction] noch kennen, wenn es um *tidy data* geht.

[^UnderConstruction]: ... falls ich mich dazu aufraffe, dieses Kapitel zu schreiben. Ansporn in Form von Feedback (positiv, negativ, hauptsache konstruktiv) ist sehr willkommen!

## Geodaten in **R**

Geodaten werden standardm√§√üig nicht von R unterst√ºtzt, doch Dank einer gro√üen, freundlichen, kompetenten Community gibt es eine riesige Menge an Erweiterungen (sogenannte *Packages*), mit denen sich der Funktionsumfang den eigenen Bed√ºrfnissen anpassen l√§sst.

Eine dieser Erweiterungen ist das **simple features** Package (*sf*). Es erlaubt das komfortable Laden, Manipulieren und Speichern von Geodaten (Points, Lines, Polygons, ...) mit Hilfe von bekannten Tools aus dem GIS-Werkzeugkasten (Puffer, Union, Projezieren, ...). Diese Werkzeuge kommen nat√ºrlich als R-Funktionen daher --- wie fast alles in **R** --- und beginnen mit "*st_*"[^st] (z.B. *st_buffer()*).

[^st]: 'st' steht f√ºr spatial/temporal...

Ein weiteres Package **mapview** erm√∂glicht die dynamische Visualisierug von Geodaten.

### Ein einfaches Beispiel:

Laden und visualisieren eines Polygons aus einem shp-File.

```{r echo=TRUE, message=FALSE, warning=FALSE}
library(sf) # lade das sf Package
library(mapview) # lade das mapview Package
library(tidyverse) # eine Sammlung gro√üartiger Packete zur Handhabe 'sauberer Daten' (optional aber sehr empfehlenswert)

# Laden eines shapefiles mit der st_read() Funktion und Ablegen in einer Variable:
ein_polygon <- st_read(dsn = "exp.shp") # "dsn" steht f√ºr data source name

# Visualisieren mit mapview():
mapview(ein_polygon)
```

```{r KarteLadenPlotten, exercise=TRUE}
setwd(wd) # Arbeitsverzeichnis festlegen, in dem die Dateien liegen.
library(sf) # sf Package laden
library(mapview) # mapview Package laden
# Erg√§nze den Code an den markierten stellen:

# Lade das Shapefile "NI_heart.shp" in eine Variable deiner Wahl:
... st_read("NI_heart.shp")
# Visualisieren mit mapview():
...
```

```{r KarteLadenPlotten-solution}
setwd(wd) # Arbeitsverzeichnis festlegen, in dem die Dateien liegen.
library(sf) # sf Package laden
library(mapview) # mapview Package laden
# Erg√§nze den Code an den markierten stellen:

# Lade das Shapefile "NI_heart.shp" in eine Variable deiner Wahl:
HerzNiedersachsens <- st_read("NI_heart.shp")
# Visualisieren mit mapview():
mapview(HerzNiedersachsens)
```

### Beispiel 2:

Wir wollen aber Geodaten verarbeiten, nicht nur angucken.
Wie w√§re es zum Beispiel mit einer Transformation in *UTM32*, Puffern, Clippen und anschlie√üendem Visualisieren?

Im Folgenden werden nacheinander verschiedene Geo-Verarbeitungsschritte vorgenomen, was entweder erfordert, dass man das Ergebnis jedes Zwischenschritts in einer eigenen Variable speichert und mit dieser im n√§chsten Schritt weiter macht ...

```{r, warning=FALSE}
# Transformation:
ein_polygon_utm32 <- st_transform(x = ein_polygon, crs = 32632)
# Puffer
ein_puffer        <- st_buffer(x = ein_polygon_utm32, dist = 222)
# Clip:
clipped           <- st_difference(x = ein_puffer, y = ein_polygon_utm32)
# Visualisierung
mapview(clipped)
```

... oder aber, man nutzt eine wunderbare Abk√ºrzung, den sogenannten Pipe-Operator `%>%`.
Damit kann man eine Abfolge von Operationen bauen, bei der immer das Ergebnis aus dem vorhergehenden Schritt die Eingabe f√ºr den nachfolgenden Schritt ist:



```{r, warning=FALSE}
ein_polygon %>%
  st_transform(crs = 32632) %>% # Transformation
  st_buffer(dist = 222) %>% # Puffer
  st_difference(st_transform(ein_polygon, crs = 32632)) %>% # Clip
  mapview() # Visualisierung

```


Jetzt bist Du wieder dran; editiere den Code so, dass anstelle der Geometrie **ein_polygon** das Herz-Polygon gepuffert wird. Lade dieses dazu bitte zun√§chst aus den Shape-files **NI_heart.shp** und w√§hle eine geeignete Pufferdistanz.

```{r HerzPuffer, exercise = TRUE}
setwd(wd) # Arbeitsverzeichnis festlegen, in dem die Dateien liegen.

...("NI_heart.shp") %>% # Polygon einlesen
  st_transform(crs = 32632) %>% # Transformation
  st_buffer(dist = ...) %>% # Puffer
  mapview() # Visualisierung
```


